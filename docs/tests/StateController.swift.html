<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>StateController.swift - Slather</title>
<link href="slather.css" media="all" rel="stylesheet">
</head>
<body>
<header><div class="row"><a href="index.html"><img src="logo.jpg" alt="Slather logo"></a></div></header><div class="row"><div id="reports">
<h2 class="cov_title">
<span>Coverage for "StateController.swift" : </span><span class="cov_low">4.45%</span>
</h2>
<h4 class="cov_subtitle">(35 of 786 relevant lines covered)</h4>
<h4 class="cov_filepath">ChatLayout/Classes/Core/Model/StateController.swift</h4>
<table class="source_code">
<tr class="never">
<td class="num">1</td>
<td class="src"><pre><code class="objc">//</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">2</td>
<td class="src"><pre><code class="objc">// ChatLayout</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">3</td>
<td class="src"><pre><code class="objc">// StateController.swift</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">4</td>
<td class="src"><pre><code class="objc">// https://github.com/ekazaev/ChatLayout</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">5</td>
<td class="src"><pre><code class="objc">//</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">6</td>
<td class="src"><pre><code class="objc">// Created by Eugene Kazaev in 2020-2022.</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">7</td>
<td class="src"><pre><code class="objc">// Distributed under the MIT license.</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">8</td>
<td class="src"><pre><code class="objc">//</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">9</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">10</td>
<td class="src"><pre><code class="objc">import Foundation</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">11</td>
<td class="src"><pre><code class="objc">import UIKit</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">12</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">13</td>
<td class="src"><pre><code class="objc">/// This protocol exists only to serve an ability to unit test `StateController`.</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">14</td>
<td class="src"><pre><code class="objc">protocol ChatLayoutRepresentation: AnyObject {</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">15</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">16</td>
<td class="src"><pre><code class="objc">    var settings: ChatLayoutSettings { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">17</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">18</td>
<td class="src"><pre><code class="objc">    var viewSize: CGSize { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">19</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">20</td>
<td class="src"><pre><code class="objc">    var visibleBounds: CGRect { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">21</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">22</td>
<td class="src"><pre><code class="objc">    var layoutFrame: CGRect { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">23</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">24</td>
<td class="src"><pre><code class="objc">    var adjustedContentInset: UIEdgeInsets { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">25</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">26</td>
<td class="src"><pre><code class="objc">    var keepContentOffsetAtBottomOnBatchUpdates: Bool { get }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">27</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">28</td>
<td class="src"><pre><code class="objc">    func numberOfItems(in section: Int) -&gt; Int</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">29</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">30</td>
<td class="src"><pre><code class="objc">    func configuration(for element: ItemKind, at itemPath: ItemPath) -&gt; ItemModel.Configuration</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">31</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">32</td>
<td class="src"><pre><code class="objc">    func shouldPresentHeader(at sectionIndex: Int) -&gt; Bool</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">33</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">34</td>
<td class="src"><pre><code class="objc">    func shouldPresentFooter(at sectionIndex: Int) -&gt; Bool</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">35</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">36</td>
<td class="src"><pre><code class="objc">}</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">37</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">38</td>
<td class="src"><pre><code class="objc">final class StateController {</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">39</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">40</td>
<td class="src"><pre><code class="objc">    private enum CompensatingAction {</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">41</td>
<td class="src"><pre><code class="objc">        case insert</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">42</td>
<td class="src"><pre><code class="objc">        case delete</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">43</td>
<td class="src"><pre><code class="objc">        case frameUpdate(previousFrame: CGRect, newFrame: CGRect)</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">44</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">45</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">46</td>
<td class="src"><pre><code class="objc">    // This thing exists here as `UICollectionView` calls `targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint)` only once at the</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">47</td>
<td class="src"><pre><code class="objc">    // beginning of the animated updates. But we must compensate the other changes that happened during the update.</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">48</td>
<td class="src"><pre><code class="objc">    var batchUpdateCompensatingOffset: CGFloat = 0</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">49</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">50</td>
<td class="src"><pre><code class="objc">    var proposedCompensatingOffset: CGFloat = 0</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">51</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">52</td>
<td class="src"><pre><code class="objc">    var totalProposedCompensatingOffset: CGFloat = 0</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">53</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">54</td>
<td class="src"><pre><code class="objc">    var isAnimatedBoundsChange = false</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">55</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">56</td>
<td class="src"><pre><code class="objc">    private(set) var storage: [ModelState: LayoutModel]</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">57</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">58</td>
<td class="src"><pre><code class="objc">    private(set) var reloadedIndexes: Set&lt;IndexPath&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">59</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">60</td>
<td class="src"><pre><code class="objc">    private(set) var insertedIndexes: Set&lt;IndexPath&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">61</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">62</td>
<td class="src"><pre><code class="objc">    private(set) var movedIndexes: Set&lt;IndexPath&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">63</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">64</td>
<td class="src"><pre><code class="objc">    private(set) var deletedIndexes: Set&lt;IndexPath&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">65</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">66</td>
<td class="src"><pre><code class="objc">    private(set) var reloadedSectionsIndexes: Set&lt;Int&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">67</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">68</td>
<td class="src"><pre><code class="objc">    private(set) var insertedSectionsIndexes: Set&lt;Int&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">69</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">70</td>
<td class="src"><pre><code class="objc">    private(set) var deletedSectionsIndexes: Set&lt;Int&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">71</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">72</td>
<td class="src"><pre><code class="objc">    private(set) var movedSectionsIndexes: Set&lt;Int&gt; = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">73</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">74</td>
<td class="src"><pre><code class="objc">    private var cachedAttributesState: (rect: CGRect, attributes: [ChatLayoutAttributes])?</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">75</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">76</td>
<td class="src"><pre><code class="objc">    private var cachedAttributeObjects = [ModelState: [ItemKind: [ItemPath: ChatLayoutAttributes]]]()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">77</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">78</td>
<td class="src"><pre><code class="objc">    private unowned var layoutRepresentation: ChatLayoutRepresentation</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">79</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">80</td>
<td class="src"><pre><code class="objc">    init(layoutRepresentation: ChatLayoutRepresentation) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">81</td>
<td class="src"><pre><code class="objc">        self.layoutRepresentation = layoutRepresentation</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">82</td>
<td class="src"><pre><code class="objc">        self.storage = [.beforeUpdate: LayoutModel(sections: [], collectionLayout: self.layoutRepresentation)]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">83</td>
<td class="src"><pre><code class="objc">        resetCachedAttributeObjects()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">84</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">85</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">86</td>
<td class="src"><pre><code class="objc">    func set(_ sections: [SectionModel], at state: ModelState) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">87</td>
<td class="src"><pre><code class="objc">        var layoutModel = LayoutModel(sections: sections, collectionLayout: layoutRepresentation)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">88</td>
<td class="src"><pre><code class="objc">        layoutModel.assembleLayout()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">89</td>
<td class="src"><pre><code class="objc">        storage[state] = layoutModel</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">90</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">91</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">92</td>
<td class="src"><pre><code class="objc">    func contentHeight(at state: ModelState) -&gt; CGFloat {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">93</td>
<td class="src"><pre><code class="objc">        guard let locationHeight = storage[state]?.sections.last?.locationHeight else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">94</td>
<td class="src"><pre><code class="objc">            return 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">95</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">96</td>
<td class="src"><pre><code class="objc">        return locationHeight + layoutRepresentation.settings.additionalInsets.bottom</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">97</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">98</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">99</td>
<td class="src"><pre><code class="objc">    func layoutAttributesForElements(in rect: CGRect,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">100</td>
<td class="src"><pre><code class="objc">                                     state: ModelState,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">101</td>
<td class="src"><pre><code class="objc">                                     ignoreCache: Bool = false) -&gt; [ChatLayoutAttributes] {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">102</td>
<td class="src"><pre><code class="objc">        let predicate: (ChatLayoutAttributes) -&gt; ComparisonResult = { attributes in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">103</td>
<td class="src"><pre><code class="objc">            if attributes.frame.intersects(rect) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">104</td>
<td class="src"><pre><code class="objc">                return .orderedSame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">105</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">106</td>
<td class="src"><pre><code class="objc">            if attributes.frame.minY &gt; rect.maxY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">107</td>
<td class="src"><pre><code class="objc">                return .orderedDescending</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">108</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">109</td>
<td class="src"><pre><code class="objc">            return .orderedAscending</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">110</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">111</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">112</td>
<td class="src"><pre><code class="objc">        if !ignoreCache,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">113</td>
<td class="src"><pre><code class="objc">           let cachedAttributesState = cachedAttributesState,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">114</td>
<td class="src"><pre><code class="objc">           cachedAttributesState.rect.contains(rect) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">115</td>
<td class="src"><pre><code class="objc">            return cachedAttributesState.attributes.binarySearchRange(predicate: predicate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">116</td>
<td class="src"><pre><code class="objc">        } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">117</td>
<td class="src"><pre><code class="objc">            let totalRect: CGRect</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">118</td>
<td class="src"><pre><code class="objc">            switch state {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">119</td>
<td class="src"><pre><code class="objc">            case .beforeUpdate:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">120</td>
<td class="src"><pre><code class="objc">                totalRect = rect.inset(by: UIEdgeInsets(top: -rect.height / 2, left: -rect.width / 2, bottom: -rect.height / 2, right: -rect.width / 2))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">121</td>
<td class="src"><pre><code class="objc">            case .afterUpdate:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">122</td>
<td class="src"><pre><code class="objc">                totalRect = rect</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">123</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">124</td>
<td class="src"><pre><code class="objc">            let attributes = allAttributes(at: state, visibleRect: totalRect)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">125</td>
<td class="src"><pre><code class="objc">            if !ignoreCache {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">126</td>
<td class="src"><pre><code class="objc">                cachedAttributesState = (rect: totalRect, attributes: attributes)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">127</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">128</td>
<td class="src"><pre><code class="objc">            let visibleAttributes = rect != totalRect ? attributes.binarySearchRange(predicate: predicate) : attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">129</td>
<td class="src"><pre><code class="objc">            return visibleAttributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">130</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">131</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">132</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">133</td>
<td class="src"><pre><code class="objc">    func resetCachedAttributes() {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">134</td>
<td class="src"><pre><code class="objc">        cachedAttributesState = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">135</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">136</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">137</td>
<td class="src"><pre><code class="objc">    func resetCachedAttributeObjects() {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">138</td>
<td class="src"><pre><code class="objc">        ModelState.allCases.forEach { state in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">139</td>
<td class="src"><pre><code class="objc">            resetCachedAttributeObjects(at: state)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">140</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">141</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">142</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">143</td>
<td class="src"><pre><code class="objc">    private func resetCachedAttributeObjects(at state: ModelState) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">144</td>
<td class="src"><pre><code class="objc">        cachedAttributeObjects[state] = [:]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">145</td>
<td class="src"><pre><code class="objc">        ItemKind.allCases.forEach { kind in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">146</td>
<td class="src"><pre><code class="objc">            cachedAttributeObjects[state]?[kind] = [:]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">147</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">148</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">149</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">150</td>
<td class="src"><pre><code class="objc">    func itemAttributes(for itemPath: ItemPath,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">151</td>
<td class="src"><pre><code class="objc">                        kind: ItemKind,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">152</td>
<td class="src"><pre><code class="objc">                        predefinedFrame: CGRect? = nil,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">153</td>
<td class="src"><pre><code class="objc">                        at state: ModelState) -&gt; ChatLayoutAttributes? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">154</td>
<td class="src"><pre><code class="objc">        let attributes: ChatLayoutAttributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">155</td>
<td class="src"><pre><code class="objc">        let itemIndexPath = itemPath.indexPath</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">156</td>
<td class="src"><pre><code class="objc">        switch kind {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">157</td>
<td class="src"><pre><code class="objc">        case .header:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">158</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">159</td>
<td class="src"><pre><code class="objc">                  itemPath.item == 0 else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">160</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">161</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">162</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">163</td>
<td class="src"><pre><code class="objc">            guard let headerFrame = predefinedFrame ?? itemFrame(for: itemPath, kind: kind, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">164</td>
<td class="src"><pre><code class="objc">                  let item = item(for: itemPath, kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">165</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">166</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">167</td>
<td class="src"><pre><code class="objc">            if let cachedAttributes = cachedAttributeObjects[state]?[.header]?[itemPath] {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">168</td>
<td class="src"><pre><code class="objc">                attributes = cachedAttributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">169</td>
<td class="src"><pre><code class="objc">            } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">170</td>
<td class="src"><pre><code class="objc">                attributes = ChatLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, with: itemIndexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">171</td>
<td class="src"><pre><code class="objc">                cachedAttributeObjects[state]?[.header]?[itemPath] = attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">172</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">173</td>
<td class="src"><pre><code class="objc">            #if DEBUG</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">174</td>
<td class="src"><pre><code class="objc">            attributes.id = item.id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">175</td>
<td class="src"><pre><code class="objc">            #endif</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">176</td>
<td class="src"><pre><code class="objc">            attributes.frame = headerFrame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">177</td>
<td class="src"><pre><code class="objc">            attributes.indexPath = itemIndexPath</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">178</td>
<td class="src"><pre><code class="objc">            attributes.zIndex = 10</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">179</td>
<td class="src"><pre><code class="objc">            attributes.alignment = item.alignment</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">180</td>
<td class="src"><pre><code class="objc">        case .footer:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">181</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">182</td>
<td class="src"><pre><code class="objc">                  itemPath.item == 0 else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">183</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">184</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">185</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">186</td>
<td class="src"><pre><code class="objc">            guard let footerFrame = predefinedFrame ?? itemFrame(for: itemPath, kind: kind, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">187</td>
<td class="src"><pre><code class="objc">                  let item = item(for: itemPath, kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">188</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">189</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">190</td>
<td class="src"><pre><code class="objc">            if let cachedAttributes = cachedAttributeObjects[state]?[.footer]?[itemPath] {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">191</td>
<td class="src"><pre><code class="objc">                attributes = cachedAttributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">192</td>
<td class="src"><pre><code class="objc">            } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">193</td>
<td class="src"><pre><code class="objc">                attributes = ChatLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionFooter, with: itemIndexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">194</td>
<td class="src"><pre><code class="objc">                cachedAttributeObjects[state]?[.footer]?[itemPath] = attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">195</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">196</td>
<td class="src"><pre><code class="objc">            #if DEBUG</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">197</td>
<td class="src"><pre><code class="objc">            attributes.id = item.id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">198</td>
<td class="src"><pre><code class="objc">            #endif</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">199</td>
<td class="src"><pre><code class="objc">            attributes.frame = footerFrame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">200</td>
<td class="src"><pre><code class="objc">            attributes.indexPath = itemIndexPath</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">201</td>
<td class="src"><pre><code class="objc">            attributes.zIndex = 10</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">202</td>
<td class="src"><pre><code class="objc">            attributes.alignment = item.alignment</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">203</td>
<td class="src"><pre><code class="objc">        case .cell:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">204</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">205</td>
<td class="src"><pre><code class="objc">                  itemPath.item &lt; layout(at: state).sections[itemPath.section].items.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">206</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">207</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">208</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">209</td>
<td class="src"><pre><code class="objc">            guard let itemFrame = predefinedFrame ?? itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">210</td>
<td class="src"><pre><code class="objc">                  let item = item(for: itemPath, kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">211</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">212</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">213</td>
<td class="src"><pre><code class="objc">            if let cachedAttributes = cachedAttributeObjects[state]?[.cell]?[itemPath] {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">214</td>
<td class="src"><pre><code class="objc">                attributes = cachedAttributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">215</td>
<td class="src"><pre><code class="objc">            } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">216</td>
<td class="src"><pre><code class="objc">                attributes = ChatLayoutAttributes(forCellWith: itemIndexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">217</td>
<td class="src"><pre><code class="objc">                cachedAttributeObjects[state]?[.cell]?[itemPath] = attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">218</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">219</td>
<td class="src"><pre><code class="objc">            #if DEBUG</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">220</td>
<td class="src"><pre><code class="objc">            attributes.id = item.id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">221</td>
<td class="src"><pre><code class="objc">            #endif</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">222</td>
<td class="src"><pre><code class="objc">            attributes.frame = itemFrame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">223</td>
<td class="src"><pre><code class="objc">            attributes.indexPath = itemIndexPath</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">224</td>
<td class="src"><pre><code class="objc">            attributes.zIndex = 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">225</td>
<td class="src"><pre><code class="objc">            attributes.alignment = item.alignment</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">226</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">227</td>
<td class="src"><pre><code class="objc">        attributes.viewSize = layoutRepresentation.viewSize</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">228</td>
<td class="src"><pre><code class="objc">        attributes.adjustedContentInsets = layoutRepresentation.adjustedContentInset</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">229</td>
<td class="src"><pre><code class="objc">        attributes.visibleBoundsSize = layoutRepresentation.visibleBounds.size</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">230</td>
<td class="src"><pre><code class="objc">        attributes.layoutFrame = layoutRepresentation.layoutFrame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">231</td>
<td class="src"><pre><code class="objc">        attributes.additionalInsets = layoutRepresentation.settings.additionalInsets</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">232</td>
<td class="src"><pre><code class="objc">        return attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">233</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">234</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">235</td>
<td class="src"><pre><code class="objc">    func itemFrame(for itemPath: ItemPath, kind: ItemKind, at state: ModelState, isFinal: Bool = false) -&gt; CGRect? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">236</td>
<td class="src"><pre><code class="objc">        guard itemPath.section &lt; layout(at: state).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">237</td>
<td class="src"><pre><code class="objc">            return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">238</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">239</td>
<td class="src"><pre><code class="objc">        guard let item = self.item(for: itemPath, kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">240</td>
<td class="src"><pre><code class="objc">            // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">241</td>
<td class="src"><pre><code class="objc">            return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">242</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">243</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">244</td>
<td class="src"><pre><code class="objc">        let section = layout(at: state).sections[itemPath.section]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">245</td>
<td class="src"><pre><code class="objc">        var itemFrame = item.frame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">246</td>
<td class="src"><pre><code class="objc">        let dx: CGFloat</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">247</td>
<td class="src"><pre><code class="objc">        let visibleBounds = layoutRepresentation.visibleBounds</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">248</td>
<td class="src"><pre><code class="objc">        let additionalInsets = layoutRepresentation.settings.additionalInsets</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">249</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">250</td>
<td class="src"><pre><code class="objc">        switch item.alignment {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">251</td>
<td class="src"><pre><code class="objc">        case .leading:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">252</td>
<td class="src"><pre><code class="objc">            dx = additionalInsets.left</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">253</td>
<td class="src"><pre><code class="objc">        case .trailing:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">254</td>
<td class="src"><pre><code class="objc">            dx = visibleBounds.size.width - itemFrame.width - additionalInsets.right</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">255</td>
<td class="src"><pre><code class="objc">        case .center:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">256</td>
<td class="src"><pre><code class="objc">            let availableWidth = visibleBounds.size.width - additionalInsets.right - additionalInsets.left</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">257</td>
<td class="src"><pre><code class="objc">            dx = additionalInsets.left + availableWidth / 2 - itemFrame.width / 2</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">258</td>
<td class="src"><pre><code class="objc">        case .fullWidth:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">259</td>
<td class="src"><pre><code class="objc">            dx = additionalInsets.left</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">260</td>
<td class="src"><pre><code class="objc">            itemFrame.size.width = layoutRepresentation.layoutFrame.size.width</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">261</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">262</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">263</td>
<td class="src"><pre><code class="objc">        itemFrame = itemFrame.offsetBy(dx: dx, dy: section.offsetY)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">264</td>
<td class="src"><pre><code class="objc">        if isFinal {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">265</td>
<td class="src"><pre><code class="objc">            itemFrame = offsetByCompensation(frame: itemFrame, at: itemPath, for: state, backward: true)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">266</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">267</td>
<td class="src"><pre><code class="objc">        return itemFrame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">268</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">269</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">270</td>
<td class="src"><pre><code class="objc">    func itemPath(by itemId: UUID, kind: ItemKind, at state: ModelState) -&gt; ItemPath? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">271</td>
<td class="src"><pre><code class="objc">        return layout(at: state).itemPath(by: itemId, kind: kind)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">272</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">273</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">274</td>
<td class="src"><pre><code class="objc">    func sectionIdentifier(for index: Int, at state: ModelState) -&gt; UUID? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">275</td>
<td class="src"><pre><code class="objc">        guard index &lt; layout(at: state).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">276</td>
<td class="src"><pre><code class="objc">            // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">277</td>
<td class="src"><pre><code class="objc">            return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">278</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">279</td>
<td class="src"><pre><code class="objc">        return layout(at: state).sections[index].id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">280</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">281</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">282</td>
<td class="src"><pre><code class="objc">    func sectionIndex(for sectionIdentifier: UUID, at state: ModelState) -&gt; Int? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">283</td>
<td class="src"><pre><code class="objc">        guard let sectionIndex = layout(at: state).sectionIndex(by: sectionIdentifier) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">284</td>
<td class="src"><pre><code class="objc">            // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">285</td>
<td class="src"><pre><code class="objc">            return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">286</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">287</td>
<td class="src"><pre><code class="objc">        return sectionIndex</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">288</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">289</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">290</td>
<td class="src"><pre><code class="objc">    func section(at index: Int, at state: ModelState) -&gt; SectionModel {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">291</td>
<td class="src"><pre><code class="objc">        guard index &lt; layout(at: state).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">292</td>
<td class="src"><pre><code class="objc">            preconditionFailure("Section index \(index) is bigger than the amount of sections \(layout(at: state).sections.count)")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">293</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">294</td>
<td class="src"><pre><code class="objc">        return layout(at: state).sections[index]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">295</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">296</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">297</td>
<td class="src"><pre><code class="objc">    func itemIdentifier(for itemPath: ItemPath, kind: ItemKind, at state: ModelState) -&gt; UUID? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">298</td>
<td class="src"><pre><code class="objc">        guard itemPath.section &lt; layout(at: state).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">299</td>
<td class="src"><pre><code class="objc">            // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">300</td>
<td class="src"><pre><code class="objc">            return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">301</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">302</td>
<td class="src"><pre><code class="objc">        let sectionModel = layout(at: state).sections[itemPath.section]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">303</td>
<td class="src"><pre><code class="objc">        switch kind {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">304</td>
<td class="src"><pre><code class="objc">        case .cell:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">305</td>
<td class="src"><pre><code class="objc">            guard itemPath.item &lt; layout(at: state).sections[itemPath.section].items.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">306</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">307</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">308</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">309</td>
<td class="src"><pre><code class="objc">            let rowModel = sectionModel.items[itemPath.item]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">310</td>
<td class="src"><pre><code class="objc">            return rowModel.id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">311</td>
<td class="src"><pre><code class="objc">        case .header, .footer:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">312</td>
<td class="src"><pre><code class="objc">            guard let item = item(for: ItemPath(item: 0, section: itemPath.section), kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">313</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">314</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">315</td>
<td class="src"><pre><code class="objc">            return item.id</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">316</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">317</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">318</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">319</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">320</td>
<td class="src"><pre><code class="objc">    func numberOfSections(at state: ModelState) -&gt; Int {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">321</td>
<td class="src"><pre><code class="objc">        return layout(at: state).sections.count</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">322</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">323</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">324</td>
<td class="src"><pre><code class="objc">    func numberOfItems(in sectionIndex: Int, at state: ModelState) -&gt; Int {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">325</td>
<td class="src"><pre><code class="objc">        return layout(at: state).sections[sectionIndex].items.count</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">326</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">327</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">328</td>
<td class="src"><pre><code class="objc">    func item(for itemPath: ItemPath, kind: ItemKind, at state: ModelState) -&gt; ItemModel? {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">329</td>
<td class="src"><pre><code class="objc">        switch kind {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">330</td>
<td class="src"><pre><code class="objc">        case .header:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">331</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">332</td>
<td class="src"><pre><code class="objc">                  itemPath.item == 0 else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">333</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">334</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">335</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">336</td>
<td class="src"><pre><code class="objc">            guard let header = layout(at: state).sections[itemPath.section].header else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">337</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">338</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">339</td>
<td class="src"><pre><code class="objc">            return header</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">340</td>
<td class="src"><pre><code class="objc">        case .footer:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">341</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">342</td>
<td class="src"><pre><code class="objc">                  itemPath.item == 0 else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">343</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">344</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">345</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">346</td>
<td class="src"><pre><code class="objc">            guard let footer = layout(at: state).sections[itemPath.section].footer else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">347</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">348</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">349</td>
<td class="src"><pre><code class="objc">            return footer</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">350</td>
<td class="src"><pre><code class="objc">        case .cell:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">351</td>
<td class="src"><pre><code class="objc">            guard itemPath.section &lt; layout(at: state).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">352</td>
<td class="src"><pre><code class="objc">                  itemPath.item &lt; layout(at: state).sections[itemPath.section].count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">353</td>
<td class="src"><pre><code class="objc">                // This occurs when getting layout attributes for initial / final animations</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">354</td>
<td class="src"><pre><code class="objc">                return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">355</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">356</td>
<td class="src"><pre><code class="objc">            return layout(at: state).sections[itemPath.section].items[itemPath.item]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">357</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">358</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">359</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">360</td>
<td class="src"><pre><code class="objc">    func update(preferredSize: CGSize, alignment: ChatItemAlignment, for itemPath: ItemPath, kind: ItemKind, at state: ModelState) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">361</td>
<td class="src"><pre><code class="objc">        guard var item = item(for: itemPath, kind: kind, at: state) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">362</td>
<td class="src"><pre><code class="objc">            assertionFailure("Item at index path (\(itemPath.section) - \(itemPath.item)) does not exist.")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">363</td>
<td class="src"><pre><code class="objc">            return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">364</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">365</td>
<td class="src"><pre><code class="objc">        var layout = self.layout(at: state)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">366</td>
<td class="src"><pre><code class="objc">        let previousFrame = item.frame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">367</td>
<td class="src"><pre><code class="objc">        cachedAttributesState = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">368</td>
<td class="src"><pre><code class="objc">        item.alignment = alignment</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">369</td>
<td class="src"><pre><code class="objc">        item.calculatedSize = preferredSize</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">370</td>
<td class="src"><pre><code class="objc">        item.calculatedOnce = true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">371</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">372</td>
<td class="src"><pre><code class="objc">        switch kind {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">373</td>
<td class="src"><pre><code class="objc">        case .header:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">374</td>
<td class="src"><pre><code class="objc">            layout.setAndAssemble(header: item, sectionIndex: itemPath.section)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">375</td>
<td class="src"><pre><code class="objc">        case .footer:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">376</td>
<td class="src"><pre><code class="objc">            layout.setAndAssemble(footer: item, sectionIndex: itemPath.section)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">377</td>
<td class="src"><pre><code class="objc">        case .cell:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">378</td>
<td class="src"><pre><code class="objc">            layout.setAndAssemble(item: item, sectionIndex: itemPath.section, itemIndex: itemPath.item)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">379</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">380</td>
<td class="src"><pre><code class="objc">        storage[state] = layout</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">381</td>
<td class="src"><pre><code class="objc">        let frameUpdateAction = CompensatingAction.frameUpdate(previousFrame: previousFrame, newFrame: item.frame)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">382</td>
<td class="src"><pre><code class="objc">        compensateOffsetIfNeeded(for: itemPath, kind: kind, action: frameUpdateAction)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">383</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">384</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">385</td>
<td class="src"><pre><code class="objc">    func process(changeItems: [ChangeItem]) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">386</td>
<td class="src"><pre><code class="objc">        batchUpdateCompensatingOffset = 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">387</td>
<td class="src"><pre><code class="objc">        proposedCompensatingOffset = 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">388</td>
<td class="src"><pre><code class="objc">        let changeItems = changeItems.sorted()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">389</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">390</td>
<td class="src"><pre><code class="objc">        var afterUpdateModel = layout(at: .beforeUpdate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">391</td>
<td class="src"><pre><code class="objc">        resetCachedAttributeObjects()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">392</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">393</td>
<td class="src"><pre><code class="objc">        changeItems.forEach { updateItem in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">394</td>
<td class="src"><pre><code class="objc">            switch updateItem {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">395</td>
<td class="src"><pre><code class="objc">            case let .sectionInsert(sectionIndex: sectionIndex):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">396</td>
<td class="src"><pre><code class="objc">                let items = (0..&lt;layoutRepresentation.numberOfItems(in: sectionIndex)).map { index -&gt; ItemModel in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">397</td>
<td class="src"><pre><code class="objc">                    let itemIndexPath = IndexPath(item: index, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">398</td>
<td class="src"><pre><code class="objc">                    return ItemModel(with: layoutRepresentation.configuration(for: .cell, at: itemIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">399</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">400</td>
<td class="src"><pre><code class="objc">                let header: ItemModel?</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">401</td>
<td class="src"><pre><code class="objc">                if layoutRepresentation.shouldPresentHeader(at: sectionIndex) == true {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">402</td>
<td class="src"><pre><code class="objc">                    let headerIndexPath = IndexPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">403</td>
<td class="src"><pre><code class="objc">                    header = ItemModel(with: layoutRepresentation.configuration(for: .header, at: headerIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">404</td>
<td class="src"><pre><code class="objc">                } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">405</td>
<td class="src"><pre><code class="objc">                    header = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">406</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">407</td>
<td class="src"><pre><code class="objc">                let footer: ItemModel?</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">408</td>
<td class="src"><pre><code class="objc">                if layoutRepresentation.shouldPresentFooter(at: sectionIndex) == true {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">409</td>
<td class="src"><pre><code class="objc">                    let footerIndexPath = IndexPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">410</td>
<td class="src"><pre><code class="objc">                    footer = ItemModel(with: layoutRepresentation.configuration(for: .footer, at: footerIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">411</td>
<td class="src"><pre><code class="objc">                } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">412</td>
<td class="src"><pre><code class="objc">                    footer = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">413</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">414</td>
<td class="src"><pre><code class="objc">                let section = SectionModel(header: header, footer: footer, items: items, collectionLayout: layoutRepresentation)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">415</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.insertSection(section, at: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">416</td>
<td class="src"><pre><code class="objc">                insertedSectionsIndexes.insert(sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">417</td>
<td class="src"><pre><code class="objc">            case let .itemInsert(itemIndexPath: indexPath):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">418</td>
<td class="src"><pre><code class="objc">                let item = ItemModel(with: layoutRepresentation.configuration(for: .cell, at: indexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">419</td>
<td class="src"><pre><code class="objc">                insertedIndexes.insert(indexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">420</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.insertItem(item, at: indexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">421</td>
<td class="src"><pre><code class="objc">            case let .sectionDelete(sectionIndex: sectionIndex):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">422</td>
<td class="src"><pre><code class="objc">                let section = layout(at: .beforeUpdate).sections[sectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">423</td>
<td class="src"><pre><code class="objc">                deletedSectionsIndexes.insert(sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">424</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.removeSection(by: section.id)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">425</td>
<td class="src"><pre><code class="objc">            case let .itemDelete(itemIndexPath: indexPath):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">426</td>
<td class="src"><pre><code class="objc">                let itemId = itemIdentifier(for: indexPath.itemPath, kind: .cell, at: .beforeUpdate)!</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">427</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.removeItem(by: itemId)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">428</td>
<td class="src"><pre><code class="objc">                deletedIndexes.insert(indexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">429</td>
<td class="src"><pre><code class="objc">            case let .sectionReload(sectionIndex: sectionIndex):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">430</td>
<td class="src"><pre><code class="objc">                reloadedSectionsIndexes.insert(sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">431</td>
<td class="src"><pre><code class="objc">                var section = layout(at: .beforeUpdate).sections[sectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">432</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">433</td>
<td class="src"><pre><code class="objc">                var header: ItemModel?</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">434</td>
<td class="src"><pre><code class="objc">                if layoutRepresentation.shouldPresentHeader(at: sectionIndex) == true {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">435</td>
<td class="src"><pre><code class="objc">                    let headerIndexPath = IndexPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">436</td>
<td class="src"><pre><code class="objc">                    header = section.header ?? ItemModel(with: layoutRepresentation.configuration(for: .header, at: headerIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">437</td>
<td class="src"><pre><code class="objc">                    header?.resetSize()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">438</td>
<td class="src"><pre><code class="objc">                } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">439</td>
<td class="src"><pre><code class="objc">                    header = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">440</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">441</td>
<td class="src"><pre><code class="objc">                section.set(header: header)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">442</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">443</td>
<td class="src"><pre><code class="objc">                var footer: ItemModel?</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">444</td>
<td class="src"><pre><code class="objc">                if layoutRepresentation.shouldPresentFooter(at: sectionIndex) == true {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">445</td>
<td class="src"><pre><code class="objc">                    let footerIndexPath = IndexPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">446</td>
<td class="src"><pre><code class="objc">                    footer = section.footer ?? ItemModel(with: layoutRepresentation.configuration(for: .footer, at: footerIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">447</td>
<td class="src"><pre><code class="objc">                    footer?.resetSize()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">448</td>
<td class="src"><pre><code class="objc">                } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">449</td>
<td class="src"><pre><code class="objc">                    footer = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">450</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">451</td>
<td class="src"><pre><code class="objc">                section.set(footer: footer)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">452</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">453</td>
<td class="src"><pre><code class="objc">                let oldItems = section.items</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">454</td>
<td class="src"><pre><code class="objc">                let items: [ItemModel] = (0..&lt;layoutRepresentation.numberOfItems(in: sectionIndex)).map { index in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">455</td>
<td class="src"><pre><code class="objc">                    var newItem: ItemModel</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">456</td>
<td class="src"><pre><code class="objc">                    if index &lt; oldItems.count {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">457</td>
<td class="src"><pre><code class="objc">                        newItem = oldItems[index]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">458</td>
<td class="src"><pre><code class="objc">                    } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">459</td>
<td class="src"><pre><code class="objc">                        let itemIndexPath = IndexPath(item: index, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">460</td>
<td class="src"><pre><code class="objc">                        newItem = ItemModel(with: layoutRepresentation.configuration(for: .cell, at: itemIndexPath.itemPath))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">461</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">462</td>
<td class="src"><pre><code class="objc">                    newItem.resetSize()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">463</td>
<td class="src"><pre><code class="objc">                    return newItem</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">464</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">465</td>
<td class="src"><pre><code class="objc">                section.set(items: items)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">466</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.removeSection(for: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">467</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.insertSection(section, at: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">468</td>
<td class="src"><pre><code class="objc">            case let .itemReload(itemIndexPath: indexPath):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">469</td>
<td class="src"><pre><code class="objc">                guard var item = self.item(for: indexPath.itemPath, kind: .cell, at: .beforeUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">470</td>
<td class="src"><pre><code class="objc">                    assertionFailure("Item at index path (\(indexPath.section) - \(indexPath.item)) does not exist.")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">471</td>
<td class="src"><pre><code class="objc">                    return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">472</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">473</td>
<td class="src"><pre><code class="objc">                item.resetSize()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">474</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">475</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.replaceItem(item, at: indexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">476</td>
<td class="src"><pre><code class="objc">                reloadedIndexes.insert(indexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">477</td>
<td class="src"><pre><code class="objc">            case let .sectionMove(initialSectionIndex: initialSectionIndex, finalSectionIndex: finalSectionIndex):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">478</td>
<td class="src"><pre><code class="objc">                let section = layout(at: .beforeUpdate).sections[initialSectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">479</td>
<td class="src"><pre><code class="objc">                movedSectionsIndexes.insert(finalSectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">480</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.removeSection(by: section.id)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">481</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.insertSection(section, at: finalSectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">482</td>
<td class="src"><pre><code class="objc">            case let .itemMove(initialItemIndexPath: initialItemIndexPath, finalItemIndexPath: finalItemIndexPath):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">483</td>
<td class="src"><pre><code class="objc">                let itemId = itemIdentifier(for: initialItemIndexPath.itemPath, kind: .cell, at: .beforeUpdate)!</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">484</td>
<td class="src"><pre><code class="objc">                let item = layout(at: .beforeUpdate).sections[initialItemIndexPath.section].items[initialItemIndexPath.item]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">485</td>
<td class="src"><pre><code class="objc">                movedIndexes.insert(initialItemIndexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">486</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.removeItem(by: itemId)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">487</td>
<td class="src"><pre><code class="objc">                afterUpdateModel.insertItem(item, at: finalItemIndexPath)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">488</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">489</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">490</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">491</td>
<td class="src"><pre><code class="objc">        afterUpdateModel = LayoutModel(sections: afterUpdateModel.sections.map { section -&gt; SectionModel in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">492</td>
<td class="src"><pre><code class="objc">            var section = section</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">493</td>
<td class="src"><pre><code class="objc">            section.assembleLayout()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">494</td>
<td class="src"><pre><code class="objc">            return section</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">495</td>
<td class="src"><pre><code class="objc">        }, collectionLayout: layoutRepresentation)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">496</td>
<td class="src"><pre><code class="objc">        afterUpdateModel.assembleLayout()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">497</td>
<td class="src"><pre><code class="objc">        storage[.afterUpdate] = afterUpdateModel</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">498</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">499</td>
<td class="src"><pre><code class="objc">        // Calculating potential content offset changes after the updates</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">500</td>
<td class="src"><pre><code class="objc">        insertedSectionsIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">501</td>
<td class="src"><pre><code class="objc">            compensateOffsetOfSectionIfNeeded(for: $0, action: .insert)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">502</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">503</td>
<td class="src"><pre><code class="objc">        reloadedSectionsIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">504</td>
<td class="src"><pre><code class="objc">            let oldSection = self.section(at: $0, at: .beforeUpdate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">505</td>
<td class="src"><pre><code class="objc">            guard let newSectionIndex = self.sectionIndex(for: oldSection.id, at: .afterUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">506</td>
<td class="src"><pre><code class="objc">                assertionFailure("Section with identifier \(oldSection.id) does not exist.")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">507</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">508</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">509</td>
<td class="src"><pre><code class="objc">            let newSection = self.section(at: newSectionIndex, at: .afterUpdate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">510</td>
<td class="src"><pre><code class="objc">            compensateOffsetOfSectionIfNeeded(for: $0, action: .frameUpdate(previousFrame: oldSection.frame, newFrame: newSection.frame))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">511</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">512</td>
<td class="src"><pre><code class="objc">        deletedSectionsIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">513</td>
<td class="src"><pre><code class="objc">            compensateOffsetOfSectionIfNeeded(for: $0, action: .delete)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">514</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">515</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">516</td>
<td class="src"><pre><code class="objc">        reloadedIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">517</td>
<td class="src"><pre><code class="objc">            guard let oldItem = self.item(for: $0.itemPath, kind: .cell, at: .beforeUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">518</td>
<td class="src"><pre><code class="objc">                  let newItemIndexPath = self.itemPath(by: oldItem.id, kind: .cell, at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">519</td>
<td class="src"><pre><code class="objc">                  let newItem = self.item(for: newItemIndexPath, kind: .cell, at: .afterUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">520</td>
<td class="src"><pre><code class="objc">                assertionFailure("Internal inconsistency")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">521</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">522</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">523</td>
<td class="src"><pre><code class="objc">            compensateOffsetIfNeeded(for: $0.itemPath, kind: .cell, action: .frameUpdate(previousFrame: oldItem.frame, newFrame: newItem.frame))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">524</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">525</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">526</td>
<td class="src"><pre><code class="objc">        insertedIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">527</td>
<td class="src"><pre><code class="objc">            compensateOffsetIfNeeded(for: $0.itemPath, kind: .cell, action: .insert)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">528</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">529</td>
<td class="src"><pre><code class="objc">        deletedIndexes.sorted(by: { $0 &lt; $1 }).forEach {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">530</td>
<td class="src"><pre><code class="objc">            compensateOffsetIfNeeded(for: $0.itemPath, kind: .cell, action: .delete)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">531</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">532</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">533</td>
<td class="src"><pre><code class="objc">        totalProposedCompensatingOffset = proposedCompensatingOffset</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">534</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">535</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">536</td>
<td class="src"><pre><code class="objc">    func commitUpdates() {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">537</td>
<td class="src"><pre><code class="objc">        insertedIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">538</td>
<td class="src"><pre><code class="objc">        insertedSectionsIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">539</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">540</td>
<td class="src"><pre><code class="objc">        reloadedIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">541</td>
<td class="src"><pre><code class="objc">        reloadedSectionsIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">542</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">543</td>
<td class="src"><pre><code class="objc">        movedIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">544</td>
<td class="src"><pre><code class="objc">        movedSectionsIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">545</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">546</td>
<td class="src"><pre><code class="objc">        deletedIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">547</td>
<td class="src"><pre><code class="objc">        deletedSectionsIndexes = []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">548</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">549</td>
<td class="src"><pre><code class="objc">        storage[.beforeUpdate] = layout(at: .afterUpdate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">550</td>
<td class="src"><pre><code class="objc">        storage[.afterUpdate] = nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">551</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">552</td>
<td class="src"><pre><code class="objc">        totalProposedCompensatingOffset = 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">553</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">554</td>
<td class="src"><pre><code class="objc">        cachedAttributeObjects[.beforeUpdate] = cachedAttributeObjects[.afterUpdate]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">555</td>
<td class="src"><pre><code class="objc">        resetCachedAttributeObjects(at: .afterUpdate)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">556</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">557</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">558</td>
<td class="src"><pre><code class="objc">    func contentSize(for state: ModelState) -&gt; CGSize {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">559</td>
<td class="src"><pre><code class="objc">        let contentHeight = self.contentHeight(at: state)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">560</td>
<td class="src"><pre><code class="objc">        guard contentHeight != 0 else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">561</td>
<td class="src"><pre><code class="objc">            return .zero</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">562</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">563</td>
<td class="src"><pre><code class="objc">        // This is a workaround for `layoutAttributesForElementsInRect:` not getting invoked enough</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">564</td>
<td class="src"><pre><code class="objc">        // times if `collectionViewContentSize.width` is not smaller than the width of the collection</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">565</td>
<td class="src"><pre><code class="objc">        // view, minus horizontal insets. This results in visual defects when performing batch</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">566</td>
<td class="src"><pre><code class="objc">        // updates. To work around this, we subtract 0.0001 from our content size width calculation;</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">567</td>
<td class="src"><pre><code class="objc">        // this small decrease in `collectionViewContentSize.width` is enough to work around the</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">568</td>
<td class="src"><pre><code class="objc">        // incorrect, internal collection view `CGRect` checks, without introducing any visual</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">569</td>
<td class="src"><pre><code class="objc">        // differences for elements in the collection view.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">570</td>
<td class="src"><pre><code class="objc">        // See https://openradar.appspot.com/radar?id=5025850143539200 for more details.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">571</td>
<td class="src"><pre><code class="objc">        let contentSize = CGSize(width: layoutRepresentation.visibleBounds.size.width - 0.0001, height: contentHeight)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">572</td>
<td class="src"><pre><code class="objc">        return contentSize</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">573</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">574</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">575</td>
<td class="src"><pre><code class="objc">    func offsetByTotalCompensation(attributes: UICollectionViewLayoutAttributes?, for state: ModelState, backward: Bool = false) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">576</td>
<td class="src"><pre><code class="objc">        guard layoutRepresentation.keepContentOffsetAtBottomOnBatchUpdates,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">577</td>
<td class="src"><pre><code class="objc">              state == .afterUpdate,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">578</td>
<td class="src"><pre><code class="objc">              let attributes = attributes else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">579</td>
<td class="src"><pre><code class="objc">            return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">580</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">581</td>
<td class="src"><pre><code class="objc">        if backward, isLayoutBiggerThanVisibleBounds(at: .afterUpdate) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">582</td>
<td class="src"><pre><code class="objc">            attributes.frame = attributes.frame.offsetBy(dx: 0, dy: totalProposedCompensatingOffset * -1)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">583</td>
<td class="src"><pre><code class="objc">        } else if !backward, isLayoutBiggerThanVisibleBounds(at: .afterUpdate) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">584</td>
<td class="src"><pre><code class="objc">            attributes.frame = attributes.frame.offsetBy(dx: 0, dy: totalProposedCompensatingOffset)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">585</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">586</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">587</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">588</td>
<td class="src"><pre><code class="objc">    func layout(at state: ModelState) -&gt; LayoutModel {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">589</td>
<td class="src"><pre><code class="objc">        guard let layout = storage[state] else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">590</td>
<td class="src"><pre><code class="objc">            assertionFailure("Internal inconsistency. Layout at \(state) is missing.")</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">591</td>
<td class="src"><pre><code class="objc">            return LayoutModel(sections: [], collectionLayout: layoutRepresentation)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">592</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">593</td>
<td class="src"><pre><code class="objc">        return layout</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">594</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">595</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">596</td>
<td class="src"><pre><code class="objc">    func isLayoutBiggerThanVisibleBounds(at state: ModelState, withFullCompensation: Bool = false) -&gt; Bool {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">597</td>
<td class="src"><pre><code class="objc">        let visibleBoundsHeight = layoutRepresentation.visibleBounds.height + (withFullCompensation ? batchUpdateCompensatingOffset + proposedCompensatingOffset : 0)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">598</td>
<td class="src"><pre><code class="objc">        return contentHeight(at: state).rounded() &gt; visibleBoundsHeight.rounded()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">599</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">600</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">601</td>
<td class="src"><pre><code class="objc">    private func allAttributes(at state: ModelState, visibleRect: CGRect? = nil) -&gt; [ChatLayoutAttributes] {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">602</td>
<td class="src"><pre><code class="objc">        let layout = self.layout(at: state)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">603</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">604</td>
<td class="src"><pre><code class="objc">        if let visibleRect = visibleRect {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">605</td>
<td class="src"><pre><code class="objc">            enum TraverseState {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">606</td>
<td class="src"><pre><code class="objc">                case notFound</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">607</td>
<td class="src"><pre><code class="objc">                case found</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">608</td>
<td class="src"><pre><code class="objc">                case done</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">609</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">610</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">611</td>
<td class="src"><pre><code class="objc">            var traverseState: TraverseState = .notFound</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">612</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">613</td>
<td class="src"><pre><code class="objc">            func check(rect: CGRect) -&gt; Bool {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">614</td>
<td class="src"><pre><code class="objc">                switch traverseState {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">615</td>
<td class="src"><pre><code class="objc">                case .notFound:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">616</td>
<td class="src"><pre><code class="objc">                    if visibleRect.intersects(rect) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">617</td>
<td class="src"><pre><code class="objc">                        traverseState = .found</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">618</td>
<td class="src"><pre><code class="objc">                        return true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">619</td>
<td class="src"><pre><code class="objc">                    } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">620</td>
<td class="src"><pre><code class="objc">                        return false</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">621</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">622</td>
<td class="src"><pre><code class="objc">                case .found:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">623</td>
<td class="src"><pre><code class="objc">                    if visibleRect.intersects(rect) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">624</td>
<td class="src"><pre><code class="objc">                        return true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">625</td>
<td class="src"><pre><code class="objc">                    } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">626</td>
<td class="src"><pre><code class="objc">                        if rect.minY &gt; visibleRect.maxY + batchUpdateCompensatingOffset + proposedCompensatingOffset {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">627</td>
<td class="src"><pre><code class="objc">                            traverseState = .done</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">628</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">629</td>
<td class="src"><pre><code class="objc">                        return false</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">630</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">631</td>
<td class="src"><pre><code class="objc">                case .done:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">632</td>
<td class="src"><pre><code class="objc">                    return false</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">633</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">634</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">635</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">636</td>
<td class="src"><pre><code class="objc">            var allRects = [(frame: CGRect, indexPath: ItemPath, kind: ItemKind)]()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">637</td>
<td class="src"><pre><code class="objc">            // I dont think there can be more then a 200 elements on the screen simultaneously</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">638</td>
<td class="src"><pre><code class="objc">            allRects.reserveCapacity(200)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">639</td>
<td class="src"><pre><code class="objc">            for sectionIndex in 0..&lt;layout.sections.count {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">640</td>
<td class="src"><pre><code class="objc">                let section = layout.sections[sectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">641</td>
<td class="src"><pre><code class="objc">                let sectionPath = ItemPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">642</td>
<td class="src"><pre><code class="objc">                if let headerFrame = itemFrame(for: sectionPath, kind: .header, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">643</td>
<td class="src"><pre><code class="objc">                   check(rect: headerFrame) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">644</td>
<td class="src"><pre><code class="objc">                    allRects.append((frame: headerFrame, indexPath: sectionPath, kind: .header))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">645</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">646</td>
<td class="src"><pre><code class="objc">                guard traverseState != .done else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">647</td>
<td class="src"><pre><code class="objc">                    break</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">648</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">649</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">650</td>
<td class="src"><pre><code class="objc">                var startingIndex = 0</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">651</td>
<td class="src"><pre><code class="objc">                // If header is not visible</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">652</td>
<td class="src"><pre><code class="objc">                if traverseState == .notFound, !section.items.isEmpty {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">653</td>
<td class="src"><pre><code class="objc">                    func predicate(itemIndex: Int) -&gt; ComparisonResult {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">654</td>
<td class="src"><pre><code class="objc">                        let itemPath = ItemPath(item: itemIndex, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">655</td>
<td class="src"><pre><code class="objc">                        guard let itemFrame = itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">656</td>
<td class="src"><pre><code class="objc">                            return .orderedDescending</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">657</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">658</td>
<td class="src"><pre><code class="objc">                        if itemFrame.intersects(visibleRect) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">659</td>
<td class="src"><pre><code class="objc">                            return .orderedSame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">660</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">661</td>
<td class="src"><pre><code class="objc">                        if itemFrame.minY &gt; visibleRect.maxY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">662</td>
<td class="src"><pre><code class="objc">                            return .orderedDescending</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">663</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">664</td>
<td class="src"><pre><code class="objc">                        return .orderedAscending</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">665</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">666</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">667</td>
<td class="src"><pre><code class="objc">                    // Find if any of the items of the section is visible</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">668</td>
<td class="src"><pre><code class="objc">                    if [ComparisonResult.orderedSame, .orderedDescending].contains(predicate(itemIndex: section.items.count - 1)),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">669</td>
<td class="src"><pre><code class="objc">                       let firstMatchingIndex = Array(0...section.items.count - 1).binarySearch(predicate: predicate) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">670</td>
<td class="src"><pre><code class="objc">                        // Find first item that is visible</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">671</td>
<td class="src"><pre><code class="objc">                        startingIndex = firstMatchingIndex</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">672</td>
<td class="src"><pre><code class="objc">                        for itemIndex in (0..&lt;firstMatchingIndex).reversed() {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">673</td>
<td class="src"><pre><code class="objc">                            let itemPath = ItemPath(item: itemIndex, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">674</td>
<td class="src"><pre><code class="objc">                            guard let itemFrame = itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">675</td>
<td class="src"><pre><code class="objc">                                continue</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">676</td>
<td class="src"><pre><code class="objc">                            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">677</td>
<td class="src"><pre><code class="objc">                            guard itemFrame.maxY &gt;= visibleRect.minY else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">678</td>
<td class="src"><pre><code class="objc">                                break</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">679</td>
<td class="src"><pre><code class="objc">                            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">680</td>
<td class="src"><pre><code class="objc">                            startingIndex = itemIndex</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">681</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">682</td>
<td class="src"><pre><code class="objc">                    } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">683</td>
<td class="src"><pre><code class="objc">                        // Otherwise we can safely skip all the items in the section and go to footer.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">684</td>
<td class="src"><pre><code class="objc">                        startingIndex = section.items.count</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">685</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">686</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">687</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">688</td>
<td class="src"><pre><code class="objc">                if startingIndex &lt; section.items.count {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">689</td>
<td class="src"><pre><code class="objc">                    for itemIndex in startingIndex..&lt;section.items.count {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">690</td>
<td class="src"><pre><code class="objc">                        let itemPath = ItemPath(item: itemIndex, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">691</td>
<td class="src"><pre><code class="objc">                        if let itemFrame = self.itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">692</td>
<td class="src"><pre><code class="objc">                           check(rect: itemFrame) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">693</td>
<td class="src"><pre><code class="objc">                            if state == .beforeUpdate || isAnimatedBoundsChange {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">694</td>
<td class="src"><pre><code class="objc">                                allRects.append((frame: itemFrame, indexPath: itemPath, kind: .cell))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">695</td>
<td class="src"><pre><code class="objc">                            } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">696</td>
<td class="src"><pre><code class="objc">                                var itemWasVisibleBefore: Bool {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">697</td>
<td class="src"><pre><code class="objc">                                    guard let itemIdentifier = self.itemIdentifier(for: itemPath, kind: .cell, at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">698</td>
<td class="src"><pre><code class="objc">                                          let initialIndexPath = self.itemPath(by: itemIdentifier, kind: .cell, at: .beforeUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">699</td>
<td class="src"><pre><code class="objc">                                          let item = self.item(for: initialIndexPath, kind: .cell, at: .beforeUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">700</td>
<td class="src"><pre><code class="objc">                                          item.calculatedOnce == true,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">701</td>
<td class="src"><pre><code class="objc">                                          let itemFrame = self.itemFrame(for: initialIndexPath, kind: .cell, at: .beforeUpdate, isFinal: false),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">702</td>
<td class="src"><pre><code class="objc">                                          itemFrame.intersects(layoutRepresentation.visibleBounds.offsetBy(dx: 0, dy: -totalProposedCompensatingOffset)) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">703</td>
<td class="src"><pre><code class="objc">                                        return false</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">704</td>
<td class="src"><pre><code class="objc">                                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">705</td>
<td class="src"><pre><code class="objc">                                    return true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">706</td>
<td class="src"><pre><code class="objc">                                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">707</td>
<td class="src"><pre><code class="objc">                                var itemWillBeVisible: Bool {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">708</td>
<td class="src"><pre><code class="objc">                                    let offsetVisibleBounds = layoutRepresentation.visibleBounds.offsetBy(dx: 0, dy: proposedCompensatingOffset + batchUpdateCompensatingOffset)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">709</td>
<td class="src"><pre><code class="objc">                                    if insertedIndexes.contains(itemPath.indexPath),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">710</td>
<td class="src"><pre><code class="objc">                                       let itemFrame = self.itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">711</td>
<td class="src"><pre><code class="objc">                                       itemFrame.intersects(offsetVisibleBounds) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">712</td>
<td class="src"><pre><code class="objc">                                        return true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">713</td>
<td class="src"><pre><code class="objc">                                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">714</td>
<td class="src"><pre><code class="objc">                                    if let itemIdentifier = self.itemIdentifier(for: itemPath, kind: .cell, at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">715</td>
<td class="src"><pre><code class="objc">                                       let initialIndexPath = self.itemPath(by: itemIdentifier, kind: .cell, at: .beforeUpdate)?.indexPath,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">716</td>
<td class="src"><pre><code class="objc">                                       movedIndexes.contains(initialIndexPath) || reloadedIndexes.contains(initialIndexPath),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">717</td>
<td class="src"><pre><code class="objc">                                       let itemFrame = self.itemFrame(for: itemPath, kind: .cell, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">718</td>
<td class="src"><pre><code class="objc">                                       itemFrame.intersects(offsetVisibleBounds) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">719</td>
<td class="src"><pre><code class="objc">                                        return true</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">720</td>
<td class="src"><pre><code class="objc">                                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">721</td>
<td class="src"><pre><code class="objc">                                    return false</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">722</td>
<td class="src"><pre><code class="objc">                                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">723</td>
<td class="src"><pre><code class="objc">                                if itemWillBeVisible || itemWasVisibleBefore {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">724</td>
<td class="src"><pre><code class="objc">                                    allRects.append((frame: itemFrame, indexPath: itemPath, kind: .cell))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">725</td>
<td class="src"><pre><code class="objc">                                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">726</td>
<td class="src"><pre><code class="objc">                            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">727</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">728</td>
<td class="src"><pre><code class="objc">                        guard traverseState != .done else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">729</td>
<td class="src"><pre><code class="objc">                            break</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">730</td>
<td class="src"><pre><code class="objc">                        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">731</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">732</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">733</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">734</td>
<td class="src"><pre><code class="objc">                if let footerFrame = itemFrame(for: sectionPath, kind: .footer, at: state, isFinal: true),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">735</td>
<td class="src"><pre><code class="objc">                   check(rect: footerFrame) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">736</td>
<td class="src"><pre><code class="objc">                    allRects.append((frame: footerFrame, indexPath: sectionPath, kind: .footer))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">737</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">738</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">739</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">740</td>
<td class="src"><pre><code class="objc">            return allRects.compactMap { frame, path, kind -&gt; ChatLayoutAttributes? in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">741</td>
<td class="src"><pre><code class="objc">                return self.itemAttributes(for: path, kind: kind, predefinedFrame: frame, at: state)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">742</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">743</td>
<td class="src"><pre><code class="objc">        } else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">744</td>
<td class="src"><pre><code class="objc">            // Debug purposes only.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">745</td>
<td class="src"><pre><code class="objc">            var attributes = [ChatLayoutAttributes]()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">746</td>
<td class="src"><pre><code class="objc">            attributes.reserveCapacity(layout.sections.count * 1000)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">747</td>
<td class="src"><pre><code class="objc">            layout.sections.enumerated().forEach { sectionIndex, section in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">748</td>
<td class="src"><pre><code class="objc">                let sectionPath = ItemPath(item: 0, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">749</td>
<td class="src"><pre><code class="objc">                if let headerAttributes = self.itemAttributes(for: sectionPath, kind: .header, at: state) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">750</td>
<td class="src"><pre><code class="objc">                    attributes.append(headerAttributes)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">751</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">752</td>
<td class="src"><pre><code class="objc">                if let footerAttributes = self.itemAttributes(for: sectionPath, kind: .footer, at: state) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">753</td>
<td class="src"><pre><code class="objc">                    attributes.append(footerAttributes)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">754</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">755</td>
<td class="src"><pre><code class="objc">                section.items.enumerated().forEach { itemIndex, _ in</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">756</td>
<td class="src"><pre><code class="objc">                    let itemPath = ItemPath(item: itemIndex, section: sectionIndex)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">757</td>
<td class="src"><pre><code class="objc">                    if let itemAttributes = self.itemAttributes(for: itemPath, kind: .cell, at: state) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">758</td>
<td class="src"><pre><code class="objc">                        attributes.append(itemAttributes)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">759</td>
<td class="src"><pre><code class="objc">                    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">760</td>
<td class="src"><pre><code class="objc">                }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">761</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">762</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">763</td>
<td class="src"><pre><code class="objc">            return attributes</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">764</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">765</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">766</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">767</td>
<td class="src"><pre><code class="objc">    private func compensateOffsetIfNeeded(for itemPath: ItemPath, kind: ItemKind, action: CompensatingAction) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">768</td>
<td class="src"><pre><code class="objc">        guard layoutRepresentation.keepContentOffsetAtBottomOnBatchUpdates else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">769</td>
<td class="src"><pre><code class="objc">            return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">770</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">771</td>
<td class="src"><pre><code class="objc">        let minY = (layoutRepresentation.visibleBounds.lowerPoint.y + batchUpdateCompensatingOffset + proposedCompensatingOffset).rounded()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">772</td>
<td class="src"><pre><code class="objc">        switch action {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">773</td>
<td class="src"><pre><code class="objc">        case .insert:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">774</td>
<td class="src"><pre><code class="objc">            guard isLayoutBiggerThanVisibleBounds(at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">775</td>
<td class="src"><pre><code class="objc">                  let itemFrame = itemFrame(for: itemPath, kind: kind, at: .afterUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">776</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">777</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">778</td>
<td class="src"><pre><code class="objc">            if itemFrame.minY.rounded() - layoutRepresentation.settings.interItemSpacing &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">779</td>
<td class="src"><pre><code class="objc">                proposedCompensatingOffset += itemFrame.height + layoutRepresentation.settings.interItemSpacing</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">780</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">781</td>
<td class="src"><pre><code class="objc">        case let .frameUpdate(previousFrame, newFrame):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">782</td>
<td class="src"><pre><code class="objc">            guard isLayoutBiggerThanVisibleBounds(at: .afterUpdate, withFullCompensation: true) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">783</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">784</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">785</td>
<td class="src"><pre><code class="objc">            if newFrame.minY.rounded() &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">786</td>
<td class="src"><pre><code class="objc">                batchUpdateCompensatingOffset += newFrame.height - previousFrame.height</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">787</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">788</td>
<td class="src"><pre><code class="objc">        case .delete:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">789</td>
<td class="src"><pre><code class="objc">            guard isLayoutBiggerThanVisibleBounds(at: .beforeUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">790</td>
<td class="src"><pre><code class="objc">                  let deletedFrame = itemFrame(for: itemPath, kind: kind, at: .beforeUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">791</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">792</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">793</td>
<td class="src"><pre><code class="objc">            if deletedFrame.minY.rounded() &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">794</td>
<td class="src"><pre><code class="objc">                // Changing content offset for deleted items using `invalidateLayout(with:) causes UI glitches.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">795</td>
<td class="src"><pre><code class="objc">                // So we are using targetContentOffset(forProposedContentOffset:) which is going to be called after.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">796</td>
<td class="src"><pre><code class="objc">                proposedCompensatingOffset -= (deletedFrame.height + layoutRepresentation.settings.interItemSpacing)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">797</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">798</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">799</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">800</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">801</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">802</td>
<td class="src"><pre><code class="objc">    private func compensateOffsetOfSectionIfNeeded(for sectionIndex: Int, action: CompensatingAction) {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">803</td>
<td class="src"><pre><code class="objc">        guard layoutRepresentation.keepContentOffsetAtBottomOnBatchUpdates else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">804</td>
<td class="src"><pre><code class="objc">            return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">805</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">806</td>
<td class="src"><pre><code class="objc">        let minY = (layoutRepresentation.visibleBounds.lowerPoint.y + batchUpdateCompensatingOffset + proposedCompensatingOffset).rounded()</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">807</td>
<td class="src"><pre><code class="objc">        switch action {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">808</td>
<td class="src"><pre><code class="objc">        case .insert:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">809</td>
<td class="src"><pre><code class="objc">            guard isLayoutBiggerThanVisibleBounds(at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">810</td>
<td class="src"><pre><code class="objc">                  sectionIndex &lt; layout(at: .afterUpdate).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">811</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">812</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">813</td>
<td class="src"><pre><code class="objc">            let section = layout(at: .afterUpdate).sections[sectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">814</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">815</td>
<td class="src"><pre><code class="objc">            if section.offsetY.rounded() - layoutRepresentation.settings.interSectionSpacing &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">816</td>
<td class="src"><pre><code class="objc">                proposedCompensatingOffset += section.height + layoutRepresentation.settings.interSectionSpacing</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">817</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">818</td>
<td class="src"><pre><code class="objc">        case let .frameUpdate(previousFrame, newFrame):</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">819</td>
<td class="src"><pre><code class="objc">            guard sectionIndex &lt; layout(at: .afterUpdate).sections.count,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">820</td>
<td class="src"><pre><code class="objc">                  isLayoutBiggerThanVisibleBounds(at: .afterUpdate, withFullCompensation: true) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">821</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">822</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">823</td>
<td class="src"><pre><code class="objc">            if newFrame.minY.rounded() &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">824</td>
<td class="src"><pre><code class="objc">                batchUpdateCompensatingOffset += newFrame.height - previousFrame.height</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">825</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">826</td>
<td class="src"><pre><code class="objc">        case .delete:</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">827</td>
<td class="src"><pre><code class="objc">            guard isLayoutBiggerThanVisibleBounds(at: .afterUpdate),</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">828</td>
<td class="src"><pre><code class="objc">                  sectionIndex &lt; layout(at: .afterUpdate).sections.count else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">829</td>
<td class="src"><pre><code class="objc">                return</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">830</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">831</td>
<td class="src"><pre><code class="objc">            let section = layout(at: .beforeUpdate).sections[sectionIndex]</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">832</td>
<td class="src"><pre><code class="objc">            if section.locationHeight.rounded() &lt;= minY {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">833</td>
<td class="src"><pre><code class="objc">                // Changing content offset for deleted items using `invalidateLayout(with:) causes UI glitches.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">834</td>
<td class="src"><pre><code class="objc">                // So we are using targetContentOffset(forProposedContentOffset:) which is going to be called after.</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">835</td>
<td class="src"><pre><code class="objc">                proposedCompensatingOffset -= (section.height + layoutRepresentation.settings.interSectionSpacing)</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">836</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">837</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">838</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">839</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">840</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">841</td>
<td class="src"><pre><code class="objc">    private func offsetByCompensation(frame: CGRect,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">842</td>
<td class="src"><pre><code class="objc">                                      at itemPath: ItemPath,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">843</td>
<td class="src"><pre><code class="objc">                                      for state: ModelState,</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="missed">
<td class="num">844</td>
<td class="src"><pre><code class="objc">                                      backward: Bool = false) -&gt; CGRect {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">845</td>
<td class="src"><pre><code class="objc">        guard layoutRepresentation.keepContentOffsetAtBottomOnBatchUpdates,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">846</td>
<td class="src"><pre><code class="objc">              state == .afterUpdate,</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">847</td>
<td class="src"><pre><code class="objc">              isLayoutBiggerThanVisibleBounds(at: .afterUpdate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">848</td>
<td class="src"><pre><code class="objc">            return frame</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">849</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">850</td>
<td class="src"><pre><code class="objc">        return frame.offsetBy(dx: 0, dy: proposedCompensatingOffset * (backward ? -1 : 1))</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">851</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="never">
<td class="num">852</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">853</td>
<td class="src"><pre><code class="objc">}</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">854</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">855</td>
<td class="src"><pre><code class="objc">extension RandomAccessCollection where Index == Int {</code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">856</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="covered">
<td class="num">857</td>
<td class="src"><pre><code class="objc">    func binarySearch(predicate: (Element) -&gt; ComparisonResult) -&gt; Index? {</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">858</td>
<td class="src"><pre><code class="objc">        var lowerBound = startIndex</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">859</td>
<td class="src"><pre><code class="objc">        var upperBound = endIndex</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">860</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">861</td>
<td class="src"><pre><code class="objc">        while lowerBound &lt; upperBound {</code></pre></td>
<td class="coverage">30x</td>
</tr>
<tr class="covered">
<td class="num">862</td>
<td class="src"><pre><code class="objc">            let midIndex = lowerBound + (upperBound - lowerBound) / 2</code></pre></td>
<td class="coverage">30x</td>
</tr>
<tr class="covered">
<td class="num">863</td>
<td class="src"><pre><code class="objc">            if predicate(self[midIndex]) == .orderedSame {</code></pre></td>
<td class="coverage">30x</td>
</tr>
<tr class="covered">
<td class="num">864</td>
<td class="src"><pre><code class="objc">                return midIndex</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">865</td>
<td class="src"><pre><code class="objc">            } else if predicate(self[midIndex]) == .orderedAscending {</code></pre></td>
<td class="coverage">20x</td>
</tr>
<tr class="missed">
<td class="num">866</td>
<td class="src"><pre><code class="objc">                lowerBound = midIndex + 1</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="covered">
<td class="num">867</td>
<td class="src"><pre><code class="objc">            } else {</code></pre></td>
<td class="coverage">20x</td>
</tr>
<tr class="covered">
<td class="num">868</td>
<td class="src"><pre><code class="objc">                upperBound = midIndex</code></pre></td>
<td class="coverage">20x</td>
</tr>
<tr class="covered">
<td class="num">869</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">20x</td>
</tr>
<tr class="missed">
<td class="num">870</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">871</td>
<td class="src"><pre><code class="objc">        return nil</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="covered">
<td class="num">872</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="never">
<td class="num">873</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="covered">
<td class="num">874</td>
<td class="src"><pre><code class="objc">    func binarySearchRange(predicate: (Element) -&gt; ComparisonResult) -&gt; [Element] {</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="missed">
<td class="num">875</td>
<td class="src"><pre><code class="objc">        guard let firstMatchingIndex = binarySearch(predicate: predicate) else {</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="missed">
<td class="num">876</td>
<td class="src"><pre><code class="objc">            return []</code></pre></td>
<td class="coverage">!</td>
</tr>
<tr class="covered">
<td class="num">877</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">878</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">879</td>
<td class="src"><pre><code class="objc">        var startingIndex = firstMatchingIndex</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">880</td>
<td class="src"><pre><code class="objc">        for index in (0..&lt;firstMatchingIndex).reversed() {</code></pre></td>
<td class="coverage">260x</td>
</tr>
<tr class="covered">
<td class="num">881</td>
<td class="src"><pre><code class="objc">            let attributes = self[index]</code></pre></td>
<td class="coverage">260x</td>
</tr>
<tr class="covered">
<td class="num">882</td>
<td class="src"><pre><code class="objc">            guard predicate(attributes) == .orderedSame else {</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">883</td>
<td class="src"><pre><code class="objc">                break</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">884</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">250x</td>
</tr>
<tr class="covered">
<td class="num">885</td>
<td class="src"><pre><code class="objc">            startingIndex = index</code></pre></td>
<td class="coverage">250x</td>
</tr>
<tr class="covered">
<td class="num">886</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">887</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">888</td>
<td class="src"><pre><code class="objc">        var lastIndex = firstMatchingIndex</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">889</td>
<td class="src"><pre><code class="objc">        for index in (firstMatchingIndex + 1)..&lt;count {</code></pre></td>
<td class="coverage">760x</td>
</tr>
<tr class="covered">
<td class="num">890</td>
<td class="src"><pre><code class="objc">            let attributes = self[index]</code></pre></td>
<td class="coverage">760x</td>
</tr>
<tr class="covered">
<td class="num">891</td>
<td class="src"><pre><code class="objc">            guard predicate(attributes) == .orderedSame else {</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">892</td>
<td class="src"><pre><code class="objc">                break</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">893</td>
<td class="src"><pre><code class="objc">            }</code></pre></td>
<td class="coverage">750x</td>
</tr>
<tr class="covered">
<td class="num">894</td>
<td class="src"><pre><code class="objc">            lastIndex = index</code></pre></td>
<td class="coverage">750x</td>
</tr>
<tr class="covered">
<td class="num">895</td>
<td class="src"><pre><code class="objc">        }</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">896</td>
<td class="src"><pre><code class="objc">        return Array(self[startingIndex...lastIndex])</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="covered">
<td class="num">897</td>
<td class="src"><pre><code class="objc">    }</code></pre></td>
<td class="coverage">10x</td>
</tr>
<tr class="never">
<td class="num">898</td>
<td class="src"><pre><code class="objc"></code></pre></td>
<td class="coverage"></td>
</tr>
<tr class="never">
<td class="num">899</td>
<td class="src"><pre><code class="objc">}</code></pre></td>
<td class="coverage"></td>
</tr>
</table>
</div></div>
<footer><div class="row">
<p><a href="https://github.com/SlatherOrg/slather">Fork me on Github</a></p>
<p>&copy; 2022 Slather</p>
</div></footer><script src="highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
